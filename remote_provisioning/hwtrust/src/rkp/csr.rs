use coset::CoseKey;
use openssl::x509::X509;
use std::{collections::HashMap, fmt};

use crate::dice::ChainForm;

use super::{DeviceInfo, ProtectedData, UdsCerts};

/// Represents the keys to sign that are to be signed
#[derive(Clone, Debug, PartialEq)]
pub struct KeysToSign(pub Vec<CoseKey>);

/// Represents the payload of a Certificate Signing Request
#[derive(Clone, PartialEq)]
pub struct CsrPayload {
    /// The original serialized CSR payload
    pub serialized: Vec<u8>,
    /// RKP VM or other?
    pub certificate_type: String,
    /// Describes the device that is requesting certificates.
    pub device_info: DeviceInfo,
    /// The keys to attest to when doing key attestation in one buffer
    pub keys_to_sign: KeysToSign,
}

/// Represents a Certificate Signing Request that is sent to an RKP backend to request
/// certificates to be signed for a set of public keys. The CSR is partially generated by an
/// IRemotelyProvisionedComponent HAL. The set of public keys to be signed is authenticated
/// (signed) with a device-unique key.
#[derive(Clone, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum Csr {
    /// CSR V2 was introduced in Android T. In this version, the payload is encrypted using
    /// an Endpoint Encryption Key (EEK).
    V2 {
        /// Describes the device that is requesting certificates.
        device_info: DeviceInfo,
        /// This is the challenge that is authenticated inside the protected data.
        challenge: Vec<u8>,
        /// Contains the plaintext of the payload that was encrypted to an EEK.
        protected_data: ProtectedData,
    },
    /// CSR V3 was introduced in Android U. This version drops encryption of the payload.
    V3 {
        /// The DICE chain for the device
        dice_chain: ChainForm,
        /// X.509 certificate chain that certifies the dice_chain root key (UDS_pub)
        uds_certs: HashMap<String, Vec<X509>>,
        /// The challenge that is authenticated inside the signed data.
        challenge: Vec<u8>,
        /// The payload of the signed data.
        csr_payload: CsrPayload,
    },
}

impl Csr {
    /// copy the DICE chain and return it
    pub fn dice_chain(&self) -> ChainForm {
        match self {
            Csr::V2 { protected_data, .. } => protected_data.dice_chain(),
            Csr::V3 { dice_chain, .. } => dice_chain.clone(),
        }
    }

    /// copy the UDS certs map and return it
    pub fn has_uds_certs(&self) -> bool {
        match self {
            Csr::V2 { protected_data, .. } => match protected_data.uds_certs() {
                Some(uds_certs) => match uds_certs {
                    UdsCerts(map) => !map.is_empty(),
                },
                None => false,
            },
            Csr::V3 { uds_certs, .. } => !uds_certs.is_empty(),
        }
    }

    /// copy the challenge and return it
    pub fn challenge(&self) -> Vec<u8> {
        match self {
            Csr::V2 { challenge, .. } => challenge.clone(),
            Csr::V3 { challenge, .. } => challenge.clone(),
        }
    }

    /// copy the serialized CSR payload and return it
    pub fn csr_payload(&self) -> Vec<u8> {
        match self {
            Csr::V2 { .. } => Vec::new(),
            Csr::V3 { csr_payload, .. } => csr_payload.serialized.clone(),
        }
    }

    /// copy the device info and return it
    pub fn compare_keys_to_sign(&self, keys_to_sign: &[u8]) -> bool {
        let keys_to_sign = match KeysToSign::from_bytes(keys_to_sign) {
            Ok(keys_to_sign) => keys_to_sign,
            Err(_) => return false,
        };

        match self {
            Csr::V2 { .. } => false,
            Csr::V3 { csr_payload, .. } => csr_payload.keys_to_sign == keys_to_sign,
        }
    }
}

impl fmt::Debug for Csr {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Csr::V2 { device_info, challenge, protected_data } => fmt
                .debug_struct("CSR V2")
                .field("DeviceInfo", &device_info)
                .field("Challenge", &hex::encode(challenge))
                .field("ProtectedData", &protected_data)
                .finish(),
            Csr::V3 { dice_chain, uds_certs, csr_payload, .. } => fmt
                .debug_struct("CSR V3")
                .field("DeviceInfo", &csr_payload.device_info)
                .field("DiceChain", &dice_chain)
                .field("UdsCerts", &uds_certs)
                .finish(),
        }
    }
}
